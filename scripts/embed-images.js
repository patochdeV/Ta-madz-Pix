#!/usr/bin/env node
/**
 * Convertit les images PNG t√©l√©charg√©es en base64 et g√©n√®re embedded-character-images.ts
 * Ex√©cution: node scripts/embed-images.js
 */

const fs = require('fs');
const path = require('path');

const ASSETS_DIR = path.join(__dirname, '..', 'assets', 'images', 'characters');
const OUT_FILE = path.join(__dirname, '..', 'data', 'embedded-character-images.ts');
const MAPPING_FILE = path.join(__dirname, '..', 'assets', 'images', 'character-images-mapping.json');

async function main() {
  console.log('üì¶ Conversion des images en base64...');

  let mapping = {};
  if (fs.existsSync(MAPPING_FILE)) {
    try {
      mapping = JSON.parse(fs.readFileSync(MAPPING_FILE, 'utf8'));
    } catch (e) {
      console.log('‚ÑπÔ∏è  Mapping non trouv√©, g√©n√©ration...');
    }
  }

  const entries = [];
  let count = 0;

  // Lire tous les fichiers PNG du dossier
  const files = fs.readdirSync(ASSETS_DIR).filter((f) => f.endsWith('.png'));

  for (const filename of files) {
    const filePath = path.join(ASSETS_DIR, filename);
    const buffer = fs.readFileSync(filePath);
    const base64 = buffer.toString('base64');
    const dataUrl = `data:image/png;base64,${base64}`;

    // Trouver la cl√© du personnage correspondant (fichier reverse lookup)
    let charName = Object.keys(mapping).find((key) => mapping[key] === filename);
    if (!charName) {
      charName = filename.replace(/\.png$/, '');
    }

    entries.push(`  '${charName}': '${dataUrl}',`);
    count++;
  }

  const content = `/**
 * Embedded character images as base64 data URLs.
 * Generated by scripts/embed-images.js
 * To regenerate after downloading new images, run: node scripts/embed-images.js
 */

export const embeddedCharacterImages: Record<string, string> = {
${entries.join('\n')}
};
`;

  fs.writeFileSync(OUT_FILE, content, 'utf8');
  console.log(`‚úÖ Generated ${OUT_FILE} with ${count} images`);
}

main().catch((err) => {
  console.error('‚ùå Error:', err);
  process.exit(1);
});
